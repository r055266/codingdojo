{"ts":1363513771352,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"#!/usr/bin/env node\n\n\"use strict\";\n\nvar fs = require('fs'),\n    util = require('util'),\n    childProcess = require('child_process'),\n    dirs = [],\n    path = require('path'),\n    exists = fs.exists || path.exists, // yay, exists moved from path to fs in 0.7.x ... :-\\\n    existsSync = fs.existsSync || path.existsSync,\n    spawn = childProcess.spawn,\n    meta = JSON.parse(fs.readFileSync(__dirname + '/package.json')),\n    exec = childProcess.exec,\n    flag = './.monitor',\n    child = null,\n    monitor = null,\n    ignoreFilePath = './.nodemonignore',\n    ignoreFileWatcher = null,\n    oldIgnoreFilePath = './nodemon-ignore',\n    ignoreFiles = [],\n    reIgnoreFiles = null,\n    timeout = 1000, // check every 1 second\n    restartDelay = 0, // controlled through arg --delay 10 (for 10 seconds)\n    restartTimer = null,\n    lastStarted = Date.now(),\n    statOffset = 0, // stupid fix for https://github.com/joyent/node/issues/2705\n    platform = process.platform,\n    isWindows = platform === 'win32',\n    noWatch = (platform !== 'win32') || !fs.watch, //  && platform !== 'linux' - removed linux fs.watch usage #72\n    watchFile = platform === 'darwin' ? fs.watchFile : fs.watch, // lame :(\n    watchWorks = true, // whether or not fs.watch actually works on this platform, tested and set later before starting\n    // create once, reuse as needed\n    reEscComments = /\\\\#/g,\n    reUnescapeComments = /\\^\\^/g, // note that '^^' is used in place of escaped comments\n    reComments = /#.*$/,\n    reTrim = /^(\\s|\\u00A0)+|(\\s|\\u00A0)+$/g,\n    reEscapeChars = /[.|\\-[\\]()\\\\]/g,\n    reAsterisk = /\\*/g,\n    // Flag to distinguish an app crash from intentional killing (used on Windows only for now)\n    killedAfterChange = false,\n    // Make this the last call so it can use the variables defined above (specifically isWindows)\n    program = getNodemonArgs(),\n    watched = [];\n\n\n\n// test to see if the version of find being run supports searching by seconds (-mtime -1s -print)\nvar testAndStart = function() {\n  var ready = function () {\n    watchFileChecker.check(function(success) {\n      watchWorks = success;\n      startNode();\n    });\n  };\n\n  if (noWatch) {\n    exec('find -L /dev/null -type f -mtime -1s -print', function(error, stdout, stderr) {\n      if (error) {\n        if (!fs.watch) {\n          util.error('\\x1B[1;31mThe version of node you are using combined with the version of find being used does not support watching files. Upgrade to a newer version of node, or install a version of find that supports search by seconds.\\x1B[0m');\n          process.exit(1);\n        } else {\n          noWatch = false;\n          ready();\n        }\n      } else {\n        // Find is compatible with -1s\n        startNode();\n      }\n    });\n  } else {\n    ready();\n  }\n}\n\n// This is a fallback function if fs.watch does not work\nfunction changedSince(time, dir, callback) {\n  callback || (callback = dir);\n  var changed = [],\n      i = 0,\n      j = 0,\n      dlen = dir.length,\n      todo = 0,\n      flen = 0,\n      done = function () {\n        todo--;\n        if (todo === 0) callback(changed);\n      };\n\n  dir = dir && typeof dir !== 'function' ? [dir] : dirs;\n\n  dir.forEach(function (dir) {\n    todo++;\n    fs.readdir(dir, function (err, files) {\n      if (err) return;\n\n      files.forEach(function (file) {\n        if (program.includeHidden === true || !program.includeHidden && file.indexOf('.') !== 0) {\n          todo++;\n          file = path.resolve(dir + '/' + file);\n          var stat = fs.stat(file, function (err, stat) {\n            if (stat) {\n              if (stat.isDirectory()) {\n                todo++;\n                changedSince(time, file, function (subChanged) {\n                  if (subChanged.length) changed = changed.concat(subChanged);\n                  done();\n                });\n              } else if (stat.mtime > time) {\n                changed.push(file);\n              }\n            }\n            done();\n          });\n        }\n      });\n      done();\n    });\n  });\n}\n\n// Attempts to see if fs.watch will work. On some platforms, it doesn't.\n// See: http://nodejs.org/api/fs.html#fs_caveats\n// Sends the callback true if fs.watch will work, false if it won't\n//\n// Caveats:\n// If there is no writable tmp directory, it will also return true, although\n// a warning message will be displayed.\n//\nvar watchFileChecker = {};\nwatchFileChecker.check = function(cb) {\n  var tmpdir,\n      seperator = '/';\n\n  this.cb = cb;\n  this.changeDetected = false;\n  if (isWindows) {\n    seperator = '\\\\';\n    tmpdir = process.env.TEMP;\n  } else if (process.env.TMPDIR) {\n    tmpdir = process.env.TMPDIR;\n  } else {\n    tmpdir = '/tmp';\n  }\n  var watchFileName = tmpdir + seperator + 'nodemonCheckFsWatch' + Date.now();\n  var watchFile = fs.openSync(watchFileName, 'w');\n  if (!watchFile) {\n    util.log('\\x1B[32m[nodemon] Unable to write to temp directory. If you experience problems with file reloading, ensure ' + tmpdir + ' is writable.\\x1B[0m');\n    cb(true);\n    return;\n  }\n  fs.watch(watchFileName, function(event, filename) {\n    if (watchFileChecker.changeDetected) { return; }\n    watchFileChecker.changeDetected = true;\n    cb(true);\n  });\n  // This should trigger fs.watch, if it works\n  fs.writeSync(watchFile, '1');\n  fs.unlinkSync(watchFileName);\n\n  setTimeout(function() { watchFileChecker.verify(); }, 250);\n};\n\n// Verifies that fs.watch was not triggered and sends false to the callback\nwatchFileChecker.verify = function() {\n  if (!this.changeDetected) {\n    this.cb(false);\n  }\n};\n\n\n\nfunction startNode() {\n  util.log('\\x1B[32m[nodemon] starting `' + program.options.exec + ' ' + program.args.join(' ') + '`\\x1B[0m');\n\n  lastStarted = Date.now();\n\n  child = spawn(program.options.exec, program.args, {\n    stdio: ['pipe', process.stdout, process.stderr]\n  });\n  \n  child.on('exit', function (code, signal) {\n    // In case we killed the app ourselves, set the signal thusly\n    if (killedAfterChange) {\n      killedAfterChange = false;\n      signal = 'SIGUSR2';\n    }\n    // this is nasty, but it gives it windows support\n    if (isWindows && signal === 'SIGTERM') signal = 'SIGUSR2';\n    // exit the monitor, but do it gracefully\n    if (signal === 'SIGUSR2') {\n      // restart\n      startNode();\n    } else if (code === 0) { // clean exit - wait until file change to restart\n      util.log('\\x1B[32m[nodemon] clean exit - waiting for changes before restart\\x1B[0m');\n      child = null;\n    } else if (program.options.exitcrash) {\n      util.log('\\x1B[1;31m[nodemon] app crashed\\x1B[0m');\n      process.exit(0);\n    } else {\n      util.log('\\x1B[1;31m[nodemon] app crashed - waiting for file changes before starting...\\x1B[0m');\n      child = null;\n    }\n  });\n\n  // pinched from https://github.com/DTrejo/run.js - pipes stdin to the child process - cheers DTrejo ;-)\n  if (program.options.stdin) {\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.pipe(child.stdin);\n  }\n\n  setTimeout(startMonitor, timeout);\n}\n\nfunction startMonitor() {\n  var changeFunction;\n\n  if (noWatch) {\n    // if native fs.watch doesn't work the way we want, we keep polling find command (mac only oddly)\n    changeFunction = function (lastStarted, callback) {\n      var cmds = [],\n          changed = [];\n\n      dirs.forEach(function(dir) {\n        cmds.push('find -L \"' + dir + '\" -type f -mtime -' + ((Date.now() - lastStarted)/1000|0) + 's -print');\n      });\n\n      exec(cmds.join(';'), function (error, stdout, stderr) {\n        var files = stdout.split(/\\n/);\n        files.pop(); // remove blank line ending and split\n        callback(files);\n      });\n    };\n  } else if (watchWorks) {\n    changeFunction = function (lastStarted, callback) {\n      // recursive watch - watch each directory and it's subdirectories, etc, etc\n      function watch(err, dir) {\n        try {\n          fs.watch(dir, { persistent: false }, function (event, filename) {\n            var filepath = path.join(dir, filename);\n            callback([filepath]);\n          });\n\n          fs.readdir(dir, function (err, files) {\n            if (!err) {\n              files.forEach(function (rawfile) {\n                var file = path.join(dir, rawfile);\n                if (-1 === watched.indexOf(file)) {\n                  fs.stat(file, function (err, stat) {\n                    if (!err && stat) {\n                      if (stat.isDirectory()) {\n                        fs.realpath(file, watch);\n                      } else {\n                        if (ignoredFilter(file)) {\n                          watched.push(file);\n                        }\n                      }\n                    }\n                  });\n                }\n              });\n            }\n          });\n        } catch (e) {\n          if ('EMFILE' === e.code) {\n            console.error('EMFILE: Watching too many files.');\n          }\n          // ignoring this directory, likely it's \"My Music\"\n          // or some such windows fangled stuff\n        }\n      }\n\n      dirs.forEach(function (dir) {\n        fs.realpath(dir, watch);\n      });\n    };\n  } else {\n    // changedSince, the fallback for when both the find method and fs.watch don't work,\n    // is not compatible with the way changeFunction works. If we have reached this point,\n    // changeFunction should not be called from herein out.\n    changeFunction = function() { util.error(\"Nodemon error: changeFunction called when it shouldn't be.\"); };\n  }\n\n  // filter ignored files\n  var ignoredFilter = function (file) {\n    // If we are in a Windows machine\n    if (isWindows) {\n      // Break up the file by slashes\n      var fileParts = file.split(/\\\\/g);\n\n      // Remove the first piece (C:)\n      fileParts.shift();\n\n      // Join the parts together with Unix slashes\n      file = '/' + fileParts.join('/');\n    }\n\n    return !reIgnoreFiles.test(file);\n  };\n\n  var isWindows = process.platform === 'win32';\n  if ((noWatch || watchWorks) && !program.options.forceLegacyWatch) {\n    changeFunction(lastStarted, function (files) {\n      if (files.length) {\n        files = files.filter(ignoredFilter);\n        if (files.length) {\n          if (restartTimer !== null) {\n            clearTimeout(restartTimer);\n          }\n\n          restartTimer = setTimeout(function () {\n            if (program.options.verbose) {\n              util.log('[nodemon] restarting due to changes...');\n            }\n            files.forEach(function (file) {\n              if (program.options.verbose) {\n                util.log('[nodemon] ' + file);\n              }\n            });\n            if (program.options.verbose) {\n              util.print('\\n\\n');\n            }\n\n            killNode();\n            \n          }, restartDelay);\n          return;\n        }\n      }\n\n      if (noWatch) setTimeout(startMonitor, timeout);\n    });\n  } else {\n    // Fallback for when both find and fs.watch don't work\n    changedSince(lastStarted, function (files) {\n      if (files.length) {\n        // filter ignored files\n        if (ignoreFiles.length) {\n          files = files.filter(function(file) {\n            return !reIgnoreFiles.test(file);\n          });\n        }\n\n        if (files.length) {\n          if (restartTimer !== null) clearTimeout(restartTimer);\n          restartTimer = setTimeout(function () {\n            if (program.options.verbose) util.log('[nodemon] restarting due to changes...');\n            files.forEach(function (file) {\n              if (program.options.verbose) util.log('[nodemon] ' + file);\n            });\n            if (program.options.verbose) util.print('\\n\\n');\n\n            killNode();\n            \n          }, restartDelay);\n          return;\n        }\n      }\n\n      setTimeout(startMonitor, timeout);\n    });\n  }\n}\n\nfunction killNode() {\n  if (child !== null) {\n    // When using CoffeeScript under Windows, child's process is not node.exe\n    // Instead coffee.cmd is launched, which launches cmd.exe, which starts node.exe as a child process\n    // child.kill() would only kill cmd.exe, not node.exe\n    // Therefore we use the Windows taskkill utility to kill the process and all its children (/T for tree)\n    if (isWindows) {\n      // For the on('exit', ...) handler above the following looks like a crash, so we set the killedAfterChange flag\n      killedAfterChange = true;\n      // Force kill (/F) the whole child tree (/T) by PID (/PID 123)\n      exec('taskkill /pid '+child.pid+' /T /F');\n    } else {\n      child.kill('SIGUSR2');\n    }\n  } else {\n    startNode();\n  }\n}\n\nfunction addIgnoreRule(line, noEscape) {\n  // remove comments and trim lines\n  // this mess of replace methods is escaping \"\\#\" to allow for emacs temp files\n  if (!noEscape) {\n    if (line = line.replace(reEscComments, '^^').replace(reComments, '').replace(reUnescapeComments, '#').replace(reTrim, '')) {\n       ignoreFiles.push(line.replace(reEscapeChars, '\\\\$&').replace(reAsterisk, '.*'));\n    }\n  } else if (line = line.replace(reTrim, '')) {\n    ignoreFiles.push(line);\n  }\n  reIgnoreFiles = new RegExp(ignoreFiles.join('|'));\n}\n\nfunction readIgnoreFile(curr, prev) {\n  var hadfile = false;\n  // unless the ignore file was actually modified, do no re-read it\n  // on darwin platform only\n  if (platform === 'darwin') {\n    if(curr && prev && curr.mtime.valueOf() === prev.mtime.valueOf()) {\n      return;\n    }\n\n    fs.unwatchFile(ignoreFilePath);\n  } else {\n    // in windows and linux use FSWatcher.close() method to stop .nodemonignore watching\n    if (ignoreFileWatcher) {\n      hadfile = true;\n      ignoreFileWatcher.close();\n    }\n  }\n\n  // Check if ignore file still exists. Vim tends to delete it before replacing with changed file\n  // uses a sync method because with programs like vi - the file\n  // gets swapped out as it's updated, and the async exists would\n  // pass, whilst the readFile would fail (because the file wasn't\n  // there anymore).\n  function checkTimer() {\n    if (existsSync(ignoreFilePath)) {\n      if (program.options.verbose) {\n        util.log('[nodemon] reading ignore list');\n      }\n\n      // ignoreFiles = ignoreFiles.concat([flag, ignoreFilePath]);\n      // addIgnoreRule(flag);\n      addIgnoreRule(ignoreFilePath.substring(2)); // ignore the ./ part of the filename\n      fs.readFileSync(ignoreFilePath).toString().split(/\\n/).forEach(function (rule, i) {\n        var noEscape = rule.substr(0,1) === ':';\n        if (noEscape) {\n          rule = rule.substr(1);\n        }\n        addIgnoreRule(rule, noEscape);\n      });\n\n      ignoreFileWatcher = watchFile(ignoreFilePath, { persistent: false }, readIgnoreFile);\n    } else if (hadfile) {\n      setTimeout(checkTimer, 100);\n    }\n  }\n\n  setTimeout(checkTimer, 100);\n}\n\n// attempt to shutdown the wrapped node instance and remove\n// the monitor file as nodemon exists\nfunction cleanup() {\n  child && child.kill();\n  // fs.unlink(flag);\n}\n\nfunction getNodemonArgs() {\n  var args = process.argv,\n      len = args.length,\n      i = 2,\n      dir = process.cwd(),\n      indexOfApp = -1,\n      app = null;\n\n  for (; i < len; i++) {\n    if (existsSync(path.resolve(dir, args[i]))) {\n      // double check we didn't use the --watch or -w opt before this arg\n      if (args[i-1] && (args[i-1] == '-w' || args[i-1] == '--watch')) {\n        // ignore\n      } else {\n        indexOfApp = i;\n        break;\n      }\n    }\n  }\n\n  if (indexOfApp !== -1) {\n    // not found, so assume we're reading the package.json and thus swallow up all the args\n    // indexOfApp = len;\n    app = process.argv[i];\n    indexOfApp++;\n  } else {\n    indexOfApp = len;\n  }\n\n  var appargs = [], //process.argv.slice(indexOfApp),\n      // app = appargs[0],\n      nodemonargs = process.argv.slice(2, indexOfApp - (app ? 1 : 0)),\n      arg,\n      options = {\n        delay: 1,\n        watch: [],\n        exec: 'node',\n        verbose: true,\n        js: false, // becomes the default anyway...\n        includeHidden: false,\n        exitcrash: false,\n        forceLegacyWatch: false, // forces nodemon to use the slowest but most compatible method for watching for file changes\n        stdin: true\n        // args: []\n      };\n\n  // process nodemon args\n  args.splice(0, 2);\n  while (arg = args.shift()) {\n    if (arg === '--help' || arg === '-h' || arg === '-?') {\n      return help(); // exits program\n    } else if (arg === '--version' || arg === '-v') {\n      return version(); // also exits\n    } else if (arg === '--js') {\n      options.js = true;\n    } else if (arg === '--quiet' || arg === '-q') {\n      options.verbose = false;\n    } else if (arg === '--hidden') {\n      options.includeHidden = true;\n    } else if (arg === '--watch' || arg === '-w') {\n      options.watch.push(args.shift());\n    } else if (arg === '--exitcrash') {\n      options.exitcrash = true;\n    } else if (arg === '--delay' || arg === '-d') {\n      options.delay = parseInt(args.shift(), 10);\n    } else if (arg === '--exec' || arg === '-x') {\n      options.exec = args.shift();\n    } else if (arg === '--legacy-watch' || arg === '-L') {\n      options.forceLegacyWatch = true;\n    } else if (arg === '--no-stdin' || arg === '-I') {\n      options.stdin = false;\n    } else if (arg === '--ext' || arg === '-e') {\n      options.ext = args.shift();\n    } else { //if (arg === \"--\") {\n      // Remaining args are node arguments\n      appargs.push(arg);\n    }\n  }\n\n  var program = { options: options, args: appargs, app: app };\n\n  getAppScript(program);\n\n  return program;\n}\n\nfunction getAppScript(program) {\n  var hokeycokey = false;\n  if (!program.args.length || program.app === null) {\n    // try to get the app from the package.json\n    // doing a try/catch because we can't use the path.exist callback pattern\n    // or we could, but the code would get messy, so this will do exactly\n    // what we're after - if the file doesn't exist, it'll throw.\n    try {\n      // note: this isn't nodemon's package, it's the user's cwd package\n      program.app = JSON.parse(fs.readFileSync('./package.json').toString()).main;\n      if (program.app === undefined) {\n        // no app found to run - so give them a tip and get the feck out\n        help();\n      }\n      program.args.unshift(program.app);\n      hokeycokey = true;\n    } catch (e) {}\n  }\n\n  if (!program.app) {\n    program.app = program.args[0];\n  }\n\n  program.app = path.basename(program.app);\n  program.ext = program.options.ext || path.extname(program.app);\n\n  if (program.options.exec.indexOf(' ') !== -1) {\n    var execOptions = program.options.exec.split(' ');\n    program.options.exec = execOptions.splice(0, 1)[0];\n    program.args = execOptions.concat(program.args);\n  }\n\n  if (program.options.exec === 'node' && program.ext === '.coffee') {\n    program.options.exec = 'coffee';\n  }\n\n  if (program.options.exec === 'coffee') {\n    if (hokeycokey) {\n      program.args.push(program.args.shift());\n    }\n\n    //coffeescript requires --nodejs --debug\n\n    // this code is a dance to get the order of the debug flags right when combined with coffeescript\n    var debugIndex = program.args.indexOf('--debug');\n    if (debugIndex === -1) {\n      debugIndex = program.args.indexOf('--debug-brk');\n    }\n\n    if (debugIndex !== -1 && program.args.indexOf('--nodejs') === -1) {\n      program.args.splice(debugIndex, 0, '--nodejs');\n    }\n    \n    // don't override user specified extention tracking\n    if (!program.options.ext) {\n      program.ext = '.coffee|.js';\n    }\n\n    if (!program.options.exec || program.options.exec === 'node') {\n      program.options.exec = 'coffee';\n    }\n\n    // because windows can't find 'coffee', it needs the real file 'coffee.cmd'\n    if (isWindows) {\n      program.options.exec += '.cmd';\n    }\n  }\n\n  // allow users to make a mistake on the program.ext to monitor\n  // converts js,jade => .js|.jade\n  // BIG NOTE: user can't do this: nodemon -e *.js\n  // because the terminal will automatically expand the glob against the file system :(\n  if (program.ext.indexOf(',') !== -1 || program.ext.indexOf('*.') !== -1) {\n    program.ext = program.ext.replace(/,/g, '|').split('|').map(function (item) {\n      return '.' + item.replace(/^[\\*\\.]+/, '');\n    }).join('|');\n  }\n}\n\nfunction findStatOffset() {\n  var filename = './.stat-test';\n  fs.writeFile(filename, function (err) {\n    if (err) return;\n    fs.stat(filename, function (err, stat) {\n      if (err) return;\n\n      statOffset = stat.mtime.getTime() - new Date().getTime();\n      fs.unlink(filename);\n    });\n  });\n}\n\nfunction version() {\n  console.log(meta.version);\n  process.exit(0);\n}\n\nfunction help() {\n  util.print([\n    '',\n    ' Usage: nodemon [options] [script.js] [args]',\n    '',\n    ' Options:',\n    '',\n    '  -d, --delay n      throttle restart for \"n\" seconds',\n    '  -w, --watch dir    watch directory \"dir\". use once for each',\n    '                     directory to watch',\n    '  -x, --exec app     execute script with \"app\", ie. -x \"python -v\"',\n    '  -I, --no-stdin     don\\'t try to read from stdin',\n    '  -q, --quiet        minimise nodemon messages to start/stop only',\n    '  --exitcrash        exit on crash, allows use of nodemon with',\n    '                     daemon tools like forever.js',\n    '  -L, --legacy-watch Forces node to use the most compatible',\n    '                     version for watching file changes',\n    '  -v, --version      current nodemon version',\n    '  -e, --ext          extensions to look for Example: \".js|.html|.css\"',\n    '  -h, --help         you\\'re looking at it',\n    '',\n    ' Note: if the script is omitted, nodemon will try to ',\n    ' read \"main\" from package.json and without a .nodemonignore,',\n    ' nodemon will monitor .js and .coffee by default.',\n    '',\n    ' Examples:',\n    '',\n    '  $ nodemon server.js',\n    '  $ nodemon -w ../foo server.js apparg1 apparg2',\n    '  $ PORT=8000 nodemon --debug-brk server.js',\n    '  $ nodemon --exec python app.py',\n    '',\n    ' For more details see http://github.com/remy/nodemon/',\n    ''\n  ].join('\\n') + '\\n');\n  process.exit(0);\n}\n\nfunction addSubdirectories() {\n  var files = fs.readdirSync(process.cwd()) || [];\n\n  files.forEach(function (file) {\n    var stat = fs.statSync(file);\n    if (stat && stat.isDirectory()) {\n      dirs.push(path.resolve(file));\n    }\n  });\n}\n\n// this little bit of hoop jumping is because sometimes the file can't be\n// touched properly, and it send nodemon in to a loop of restarting.\n// this way, the .monitor file is removed entirely, and recreated with\n// permissions that anyone can remove it later (i.e. if you run as root\n// by accident and then try again later).\n// if (path.existsSync(flag)) fs.unlinkSync(flag);\n// fs.writeFileSync(flag, '.'); // requires some content https://github.com/remy/nodemon/issues/36\n// fs.chmodSync(flag, '666');\n\n// remove the flag file on exit\nprocess.on('exit', function (code) {\n  if (program.options.verbose) util.log('[nodemon] exiting');\n  cleanup();\n});\n\nif (!isWindows) { // because windows borks when listening for the SIG* events\n  // usual suspect: ctrl+c exit\n  process.on('SIGINT', function () {\n    child && child.kill('SIGINT');\n    cleanup();\n    process.exit(0);\n  });\n\n  process.on('SIGTERM', function () {\n    cleanup();\n    process.exit(0);\n  });\n}\n\n// TODO on a clean exit, we could continue to monitor the directory and reboot the service\n\n// on exception *inside* nodemon, shutdown wrapped node app\nprocess.on('uncaughtException', function (err) {\n  util.log('[nodemon] exception in nodemon killing node');\n  util.error(err.stack);\n  cleanup();\n});\n\n\nif (program.options.delay) {\n  restartDelay = program.options.delay * 1000;\n}\n\n// this is the default - why am I making it a cmd line opt?\nif (program.options.js) {\n  addIgnoreRule('^((?!\\.js|\\.coffee$).)*$', true); // ignores everything except JS\n}\n\nif (program.options.watch && program.options.watch.length > 0) {\n  program.options.watch.forEach(function (dir) {\n    dirs.push(path.resolve(dir));\n  });\n} else {\n  dirs.unshift(process.cwd());\n}\n\nif (!program.app) {\n  help();\n}\n\nif (program.options.verbose) {\n  util.log('[nodemon] v' + meta.version);\n}\n\n// this was causing problems for a lot of people, so now not moving to the subdirectory\n// process.chdir(path.dirname(app));\ndirs.forEach(function(dir) {\n  if (program.options.verbose) {\n    util.log('\\x1B[32m[nodemon] watching: ' + dir + '\\x1B[0m');\n  }\n});\n\n// findStatOffset();\n\nif (program.options.ext) {\n  addIgnoreRule('^((?!' + program.ext.replace(/\\./g, '\\\\.') + '$).)*$', true);\n}\n\nexists(ignoreFilePath, function (exist) {\n  // watch it: \"exist\" not to be confused with \"exists\"....\n  if (!exist) {\n    // try the old format\n    exists(oldIgnoreFilePath, function (exist) {\n      if (exist) {\n        if (program.options.verbose) {\n          util.log('[nodemon] detected old style .nodemonignore');\n        }\n        ignoreFilePath = oldIgnoreFilePath;\n      } else {\n        // don't create the ignorefile, just ignore the flag & JS\n        // addIgnoreRule(flag);\n        if (!program.options.ext) {\n          var ext = program.ext.replace(/\\./g, '\\\\.');\n          if (ext) {\n            addIgnoreRule('^((?!' + ext + '$).)*$', true);\n          } else {\n            addIgnoreRule('^((?!\\.js|\\.coffee$).)*$', true); // ignores everything except JS\n          }\n        }\n      }\n    });\n  } else {\n    readIgnoreFile();\n  }\n});\n\ntestAndStart();\n"]],"start1":0,"start2":0,"length1":0,"length2":25250}]],"length":25250}
{"contributors":[],"silentsave":false,"ts":1363514155366,"patch":[[{"diffs":[[0,"ir, filename"],[1," || ''"],[0,");\n         "]],"start1":7948,"start2":7948,"length1":24,"length2":30}]],"length":25256,"saved":false}
